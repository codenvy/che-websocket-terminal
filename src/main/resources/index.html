<html>
<body>

<div id="bash" style="width: 100%; height: 100%; background-color: gray;"></div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

<script src="./term.js" type="text/javascript"></script>

<script>
    $(document).ready(function () {
        var socketUrl = window.location.host + "/pty";
        if (window.location.protocol === "https:") {
            socketUrl = "wss://" + socketUrl;
        } else {
            socketUrl = "ws://" + socketUrl;
        }
        var sock = new WebSocket(socketUrl);

        sock.onerror = function (e) {
            console.log("socket error", e);
        };


        // wait for the socket to open before starting the terminal
        // or there will be ordering issues :/
        var timer;
        sock.onopen = function (e) {
            $(window).resize(function () {
//                setSize();
                if(timer != undefined){
                    clearTimeout(timer);
                }
                timer = setTimeout(setSize, 500);
            });

            var setSize = function () {
                var bash = $("#bash");
                var x = Math.floor(bash.width() / 6.6221374) -1;
                var y = Math.floor(bash.height() / 13);
                term.resize(x, y);
                sock.send(JSON.stringify({
                        type : "resize",
                        "data" : [x,y]
                        }));
               // sock.send("")
            };
            var term = new Terminal({
                cols: 200,
                rows: 60,
                useStyle: true,
                screenKeys: true
            });

            term.open(document.getElementById("bash"));


            term.on('title', function (title) {
                document.title = title;
            });
            setSize();
            // pass data using base64 encoding
            // this is fragile: it will not work with non-ascii text!
            // the Go backend is correctly treating pty IO as opaque
            // byte arrays, while term.js uses javascript strings that
            // are utf16, while the pty is usually utf8.
            // I have some Go code that converts to utf16 before sending but
            // it's ugly and wrong. The right answer is to refactor term.js to use
            // ArrayBuffer with uint8 and convert runes on the fly on the client
            term.on('data', function (data) {
                sock.send(JSON.stringify({
                    type : "data",
                    "data" : data
                }));
            });

            sock.onmessage = function (msg) {
                term.write(msg.data);
            };
        };
    });
</script>
</body>
</html>
